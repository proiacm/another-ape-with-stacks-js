'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var connect = require('@stacks/connect');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var States;

(function (States2) {
  States2["UPDATE_AUTH_OPTIONS"] = "data/update-auth-options";
})(States || (States = {}));

var initialState = {
  isOpen: false,
  isAuthenticating: false,
  authData: void 0,
  userSession: void 0,
  authOptions: {
    redirectTo: "",
    manifestPath: "",
    onFinish: function onFinish() {
      return null;
    },
    authOrigin: void 0,
    sendToSignIn: false,
    appDetails: {
      name: "",
      icon: ""
    }
  }
};

var connectReducer = function connectReducer(state, _ref) {
  var type = _ref.type,
      payload = _ref.payload;

  switch (type) {
    case States.UPDATE_AUTH_OPTIONS:
      {
        return _extends({}, state, {
          authOptions: _extends({}, state.authOptions, payload)
        });
      }

    default:
      {
        throw new Error("Unhandled action type: " + type);
      }
  }
};

var ConnectContext = /*#__PURE__*/React.createContext(initialState);
var ConnectDispatchContext = /*#__PURE__*/React.createContext(void 0);

var ConnectProvider = function ConnectProvider(_ref2) {
  var authOptions = _ref2.authOptions,
      children = _ref2.children;

  var _useReducer = React.useReducer(connectReducer, initialState),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  return /* @__PURE__ */React__default.createElement(ConnectContext.Provider, {
    value: _extends({}, state, {
      authOptions: authOptions
    })
  }, /* @__PURE__ */React__default.createElement(ConnectDispatchContext.Provider, {
    value: dispatch
  }, children));
};

var Connect = function Connect(_ref) {
  var authOptions = _ref.authOptions,
      children = _ref.children;
  return /* @__PURE__ */React__default.createElement(ConnectProvider, {
    authOptions: authOptions
  }, children);
};

var useConnectDispatch = function useConnectDispatch() {
  var dispatch = React.useContext(ConnectDispatchContext);

  if (!dispatch) {
    throw new Error("This must be used within the ConnectProvider component.");
  }

  return dispatch;
};

var useConnect = function useConnect() {
  var _useContext = React.useContext(ConnectContext),
      isOpen = _useContext.isOpen,
      isAuthenticating = _useContext.isAuthenticating,
      authData = _useContext.authData,
      authOptions = _useContext.authOptions,
      userSession = _useContext.userSession;

  var dispatch = useConnectDispatch();

  var doUpdateAuthOptions = function doUpdateAuthOptions(payload) {
    return dispatch({
      type: States.UPDATE_AUTH_OPTIONS,
      payload: payload
    });
  };

  var doOpenAuth = function doOpenAuth(signIn, options) {
    if (signIn) {
      var _options = _extends({}, authOptions, options, {
        onFinish: function onFinish(payload) {
          var _authOptions$onFinish;

          (_authOptions$onFinish = authOptions.onFinish) === null || _authOptions$onFinish === void 0 ? void 0 : _authOptions$onFinish.call(authOptions, payload);
        },
        sendToSignIn: true
      });

      void connect.authenticate(_options);
      return;
    } else {
      connect.showBlockstackConnect(_extends({}, authOptions, {
        sendToSignIn: false
      }));
    }

    authOptions && doUpdateAuthOptions(authOptions);
  };

  var doAuth = function doAuth(options) {
    if (options === void 0) {
      options = {};
    }

    void connect.authenticate(_extends({}, authOptions, options, {
      onFinish: function onFinish(payload) {
        var _authOptions$onFinish2;

        (_authOptions$onFinish2 = authOptions.onFinish) === null || _authOptions$onFinish2 === void 0 ? void 0 : _authOptions$onFinish2.call(authOptions, payload);
      }
    }));
  };

  function doContractCall(options) {
    return connect.openContractCall(_extends({}, options, {
      authOrigin: authOptions.authOrigin,
      appDetails: authOptions.appDetails
    }));
  }

  function doContractDeploy(options) {
    return connect.openContractDeploy(_extends({}, options, {
      authOrigin: authOptions.authOrigin,
      appDetails: authOptions.appDetails
    }));
  }

  function doSTXTransfer(options) {
    return connect.openSTXTransfer(_extends({}, options, {
      authOrigin: authOptions.authOrigin,
      appDetails: authOptions.appDetails
    }));
  }

  function sign(options) {
    return connect.openSignatureRequestPopup(_extends({}, options, {
      authOrigin: authOptions.authOrigin,
      appDetails: authOptions.appDetails
    }));
  }

  function signStructuredData(options) {
    return connect.openStructuredDataSignatureRequestPopup(_extends({}, options, {
      authOrigin: authOptions.authOrigin,
      appDetails: authOptions.appDetails
    }));
  }

  return {
    isOpen: isOpen,
    isAuthenticating: isAuthenticating,
    authData: authData,
    authOptions: authOptions,
    userSession: userSession,
    doOpenAuth: doOpenAuth,
    doAuth: doAuth,
    authenticate: connect.authenticate,
    doContractCall: doContractCall,
    doContractDeploy: doContractDeploy,
    doSTXTransfer: doSTXTransfer,
    sign: sign,
    signStructuredData: signStructuredData
  };
};

Object.keys(connect).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return connect[k];
    }
  });
});
exports.Connect = Connect;
exports.useConnect = useConnect;
//# sourceMappingURL=connect-react.cjs.development.js.map
